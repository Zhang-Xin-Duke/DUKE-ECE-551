## 0, 准备工作

**工作写项目的流程**

>```C
>// 1, 和甲方沟通 
>// 2, 产品经理: 总结之前的沟通信息, 变成文档/图
>// 3, 分配人力: ui, 开发, 开发, 测试,  运维 
>// 4, 开始的时候:  ui+产品 -> 原型图
>// 5, 开始的时候: 1-2-3开发, 项目框架搭建起来.  工具类/数据库基础表/..... 和业务无关
>//              项目描述文档: 
>// 6, 追加项目组成员5个人: 研究项目描述文档 + 研究产品提供需求文档/原型图
>//              (1), 甘特图, 记录项目的开发进度
>//              (2), 分配任务:  5 -> 10天, 5天
>//              (3), 接到任务: 根据需求写文档: 代码设计,功能设计 -> 类图 , er图-> 
>//              (4), 先写头文件:  再实现文件
>//              (5), 之前的设计不对, 有bug 
>//              (6), 两个开发之间, 代码之间存在相互调用关系:  接口文档
>```

**开会**

>```C
>// 1, 讨论: 基本框架逻辑, 确定谁先构架框架, ( /梳理出整体.c文件/函数有那些/调用关系->类图:大致确定代码怎么写/设计;   ER图 )
>// 2, (每天沟通讨论的事情)分析难点沟通思路 ( 一些实现要点的实现思路沟通商讨 )
>// 2, 设计初版头文件 ( 头文件: 基本的数据结构, 函数定义 -> 初版 )
>// 3, (每天)分配任务 ( 根据实际情况 )
>// 4, 更新进度记录表: 待做项
>```

**共享进度表**

>```C
>// 1, 维护记录表:  甘特图
>//              项目框架/设计/头文件/图
>//				版本
>//				待做项: 
>//				已做项:
>//				进行中
>```

## 1, 第一期

### 1.1 功能要求

#### 基础的框架和命令

>客户端: 
>
>```C
>客户端和服务端建立连接:
>// 和服务端建立连接
>客户端读取标准输入:
>// 读取标准输入输入的内容
>// 分析内容: 得到命令和参数, 判断命令和参数是否合法, 以及过滤无效内容
>// 把命令和参数发送给服务器
>客户端可以输入以下命令(对服务器上的文件进行查看):
>// cd 进入对应目录
>// ls 列出相应目录文件
>// puts 将本地文件上传至服务器
>// gets 文件名 下载服务器文件到本地
>// remove/rm 删除服务器上文件
>// pwd 显示目前所在路径
>// 其他命令可以自己选择性的添加（mkdir 等等）
>// 无效命令不响应
>```
>
>服务端:
>
>```C
>启动服务器, 接收客户端连接:
>// 接收客户端连接, 交给子线程
>等待客户端请求内容:
>// 客户端发送命令, 接收命令, 分析命令
>// 根据命令做出对应反应(回应文件列表/接收客户端传输文件/传输文件给客户端/删除文件/显示路径...)
>```

#### 服务端使用日志记录信息:

>```C
>// 要求服务端通过日志记录客户端请求信息 (自选记录那些)
>// 要求服务端通过日志记录客户端连接时间 (自选格式)
>// 要求服务端通过日志记录客户端操作记录(比如删除文件,上传文件...)及什么时候操作的 (自选记录行为)
>```

#### 引入配置文件: (公共需求配置化)

>```C
>// 在一个真正的项目中, 必然存在配置文件, 用来配置项目的基本信息.
>
>比如:
>// 在小组开发中, 我们每个人的IP地址都不同, 但是我们要共用一份代码, 如果我们在代码中把IP地址写死, 比如我把代码中的IP地址改成我的IP, 那么每次git提交, 同桌pull之后都要重新修改IP地址为他的IP地址, 极不方便, 也容易产生git冲突. (虽然, 我们也可以使用传统的方式, 在启动命令后面加IP参数, 但是诚实的讲, 极不专业, 也不高明)
>// 我们每个人在后面写代码的时候都要连接自己的数据库, 但是由于数据库的密码每个人可能不同, 如果写死在代码里, 也要改来改去, 容易产生冲突
>// .....
>
>// 所以在一个正常的真正的项目中, 必然存在配置文件, 用来配置项目的基本信息. 这个配置文件记录了一些配置信息(我们可以选择不提交: 即git忽略这个配置文件), 然后让我们的代码对IP/端口/数据库密码/日志级别....信息, 通过动态加载的方式, 加载到代码中, 以方便使用.
>```

#### 日志配置化(该功能选作)

>```C
>// 我们知道, 日志是有多个级别的. 而在一般工作中, 我们在日常开发代码中, 为了让更好的追踪代码的运行过程, 以便于代码书写和调试BUG, 我们会把日志的级别设置的比较低(比如: INFO, DEBUG), 让日志尽可能打印更多的信息, 方便追踪代码运行过程.
>// 但是打印这么多的日志信息, 在生产环境上是行不通的, 一方面是因为一些类似INFO的提示信息,或者类似DEBUG的信息, 我们在生产环境(给用户使用的环境)上没有必要关注(这些信息是写代码的时候详细追踪代码运行过程用的); 另一方面, 日志级别越低, 打印的信息越多, 会导致我们的程序花费很多时间在打印日志上, 导致服务器性能空耗.
>
>// 所以标准来讲, 我们希望在不同情况下(比如: 开发环节, 测试环节, 生产环节...), 同一份代码, 可以有选择的动态的根据情况选择日志的打印级别.
>// 而上面的配置文件, 就是在工作中, 一种非常常见的手法
>
>// 结合上面的配置文件配置项, 当程序运行的时候, 我们先从配置文件中读取当前设置的日志级别是什么级别(比如开发我们可能会在配置文件中把LOG选项设置LOG=INFO, 给用户用的生产环境我们会把配置文件中的LOG设置为LOG=ERROR),
>
>// 这样程序一旦启动, 就可以读取到当前在配置文件中预设的日志级别, 代码就知道只需要打印那个级别的日志了
>// 又结合我们前面设置的日志宏函数, 我们可以让宏函数, 根据从配置文件中读取到的日志级别, 有选择的打印日志(即: 如果调用这个日志宏函数的时候, 如果传入的日志级别, 是低于从配置文件中读取到的日志级别的话, 直接让宏函数返回, 不做打印)
>
>// 这也就要求我们, 在代码中调用宏函数的时候, 针对不同的打印情况, 应该给宏函数传入不同的日志级别.(例如: 传输文件出错/下载文件出错/连接突然断开...这种比较严重的情况应该在调用日志宏打印日志的时候, 日志级别尽可能高)(例如: 用户执行了一个CD操作这种不那么重要的操作, 在调用日志宏函数打印日志的时候, 我们传给日志宏的日志级别应该低一些才好 )
>```

### 1.2 一些想法

#### 命令切割

>假设客户端从标准输入中读取到一个命令, 怎么对命令进程拆分(拆分出指令部分 和 参数部分):  [eg: cd  dir] 
>
>```C
>方式一:
>// 手动处理读取的字符串
>方式二:
>// 使用strtok切割字符
>方式三:
>// 其它方法....
>```
>
>```C
>int main(int argc,char*argv[])
>{
>       char str[] = "cd    abc/def/dir";
>        // mkdir x
>        // rm   x
>
>       char *p = strtok(str,  " ");
>       printf( "p=%s  \n",   p);
>       //p = strtok(NULL,  " /");
>       p = strtok(NULL,  "/");
>       printf( "p=%s  \n",   p);
>       p = strtok(NULL,  "/");
>       printf( "p=%s  \n",   p);
>       p = strtok(NULL,  "/");
>       printf( "p=%s  \n",   p);
>       return 0;
>}
>```

#### 虚拟路径

>服务器需要按照目录森林, 区分用户/区分一个用户不同目录

>在客户端:
>
>```C
>// 用户通过pwd命令看到的并不是一个真实的路径, 而是服务器返回的一个虚拟路径 (根据你是哪个用户)
>```
>
>在服务端
>
>```C
>// 服务器可能以某个/x/y/路径为基础起点下/:  在这个目录内部构建一个树状目录结构给用户使用,对应用户看到的路径
>```
>

#### 多个用户

> 暂时不要求做真实用户: 虚假的用户

>如果要组织多个用户, 肯定在上面的(上面举例:  /x/y/路径为基础)基础目录下, 维护多个目录(eg: zs文件夹, ls文件夹...)用来区分用户.
>
>假设多个用户怎么组织文件?  (暂时使用虚假的用户模拟登录和区分)
>
>```C
>// 目录森林结构
>```

#### 删除文件 

>当客户端, 发送删除文件的命令
>
>```C
>// 服务器除了对删除命令进行基本的命令以及参数的识别和校验, 还需要对文件进行删除.
>删除方式有多种方式: (下面仅属于闲聊)
>方式一: C标准库中的remove函数
>方式二: POSIX标准中的unlink函数
>方式三: 调用系统命令删除 (system (rm 文件名))
>方式四: .....
>```

#### 查看某个目录下有那些文件

>当客户端发送对应请求查看某个路径下的文件,  怎么获取指定目录下所有文件名?
>
>```C
>opendir(const char *name): 打开一个目录，返回一个DIR类型的指针
>readdir(DIR *dirp): 从dirp指向的目录流中读取下一个目录项，并返回一个指向dirent结构的指针
>closedir(DIR *dirp): 关闭之前由opendir打开的目录流
>```

#### 其它

>`access`函数是用来检查调用进程是否可以对指定的文件进行某种形式的访问 (man access )
>
>....

#### 日志的一些问题

>ps: 在做如下操作前, 记得保存Linux系统内资源到本地(担心没有按照流程导致系统崩溃), 以及拍快照

问题:

>如果大家有印象的话, 我们前面介绍过一个叫syslog的函数:
>
>```C
>// (man 3 syslog) 
>#include <syslog.h>
>
>void syslog(
>       int priority,//日志级别:LOG_ERR、LOG_WARNING、LOG_INFO等
>       const char *format,//格式字符串
>       ...//可变参数
>);
>// ps: 以我们的系统为例, 日志信息存在: /var/log/syslog上
>```
>
>但是上面的日志, 默认是输入到系统的/var/log/syslog文件上.
>
>假设我想有一个自己的日志的单独记录的地方, 怎么处理?
>
>实际上系统中除了syslog函数, 还有一个openlog函数: 
>
>```C
>// 允许指定一些与日志消息相关的设置，这些设置会应用于随后通过syslog函数发送的所有消息。
>// (man 3 syslog) 
>#include <syslog.h>
>
>void openlog(
>    const char *ident, // 是一个字符串:它会被添加到日志消息的开头，作为消息的前缀，以便在查看系统日志时可以容易地识别出消息来源
>    int option,// 用于指定日志处理的选项:
>    int facility// 指定消息的类型或来源
>);
>
>option：选项
>// LOG_PID：在每条日志消息中包含程序的进程ID。
>// LOG_CONS：如果消息不能记录到日志中，则输出到系统控制台。
>// LOG_PERROR：将日志消息同时输出到标准错误输出（stderr）和系统日志。
>// ...
>
>facility：参数
>// LOG_AUTH（认证系统）
>// LOG_DAEMON（系统守护进程）
>// LOG_USER（一般用户级消息)    
>// LOG_LOCAL0 到 LOG_LOCAL7 是在 syslog 协议中预留的8个日志设施
>```

修改配置:

>- 找到/etc/rsyslog.d文件夹
>- 创建一个.conf文件,  可能需要加上sudo权限.  (eg:  sudo  vim snow.conf  )
>- 在这个文件中, 配置日志的记录格式
>
>```ini
># 仅示例:
># 把LOG_LOCAL0的info以及以上级别的信息记录到/var/log/snow_info.log文件中
>local0.info    /var/log/snow_info.log   
># 把LOG_LOCAL0的err以及以上级别的信息记录到/var/log/snow_err.log文件中
>local0.err    /var/log/snow_err.log
># ...
>```
>
>- 重启日志系统: sudo systemctl restart rsyslog

使用:

>假设使用代码:
>
>```C
>#include <syslog.h>
>int main() {
>
>       openlog("snow::", LOG_PID|LOG_CONS, LOG_LOCAL0);
>
>       syslog(LOG_INFO, "info msg by snow ");
>       syslog(LOG_WARNING, "warning msg by snow ");
>       syslog(LOG_ERR, "err msg by snow ");
>
>       closelog();
>
>       return 0;
>}
>```

观察日志结果:

>比如我把日志记录在
>
>```C
>/var/log/snow_info.log   
>/var/log/snow_err.log
>```
>
>我就可以切换到这两个目录观察日志文件是否存在以及具有日志内容

一些系统提供的宏:

>在C语言中, 有几个用来提供关于信息标识的些宏
>
>```C
>// __LINE__: 当前源代码行号
>// __FUNCTION__:当前函数名称的字符串
>// __FILE__:源文件名的字符串
>```
>
>```C
>// 示例代码
>#include <55header.h>
>
>void func(int num, const char *funname, const char *name){
>
>	printf("%s: %s: %d \n", name, funname, num);
>
>}
>int main(int argc,char*argv[])
>{
>       func(__LINE__, __FUNCTION__, __FILE__);
>
>       func(__LINE__, __FUNCTION__, __FILE__);
>
>       return 0;
>}
>```

手动封装日志:

>上面我们讲了, 借助系统的功能封装日志记录. 但是借助系统日志操作第一太麻烦, 第二毕竟没有自己写代码的操控灵活, 如果有余力可以选择,完全脱离系统日志,  自己基于我们见面学的类似open/write...自己封装文件操作的日志系统.  

日志宏:

>结合上面讲过的东西, 把syslog封装成一个宏(类似我们调用ERROR_CHECK做错误检查一样),  方便日志输出.
>
>或者
>
>完全不依赖于syslog,  使用手动封装日志自定义函数的方式, 封装出一个宏(类似我们调用ERROR_CHECK做错误检查一样),  方便日志输出.

#### 配置文件

>所谓配置文件, 就是在一个项目中, 把不合适硬编码的内容, 放到配置文件中, 然后让代码动态加载这个配置文件的内容, 进而填充代码内部需要参数的位置.

>文件: config.ini
>
>```ini
>ip=192.168.106.129
>port=8080
>mysql_user=root
>mysql_password=zs123456
>log=error
>```
>
>文件: load_config.c
>
>```C
>#include <55header.h>
>
>int getparameter(char *key, char *value){
>
>FILE * file = fopen("config.ini", "r");
>while(1){
>char line[100];
>bzero(line, sizeof(line));
>// 读一行数据
>char *res = fgets(line, sizeof(line), file);
>if(res == NULL){
>  char buf[] = "没有要找的内容 \n";
>  memcpy(value, buf, strlen(buf));
>  return -1;
>}
>// 处理数据
>char *line_key = strtok(line, "=");
>if(strcmp(key, line_key) == 0){
>  // 要找的内容
>  char *line_value = strtok(NULL, "=");
>  memcpy(value, line_value, strlen(line_value));
>  return 0;
>}
>}
>
>return 0;
>}
>int main(int argc,char*argv[])
>{
>char ip[100];
>bzero(ip, sizeof(ip));
>getparameter("ip", ip);
>printf("ip is = %s", ip);
>
>char port[100];
>bzero(port, sizeof(port));
>getparameter("port", port);
>printf("port is = %s", port);
>
>char file[100];
>bzero(file, sizeof(file));
>getparameter("file", file);
>printf("file is = %s", file);
>
>char name[100];
>bzero(name, sizeof(name));
>getparameter("mysql_user", name);
>printf("mysql_user is = %s", name);
>
>return 0;
>}
>```

## 2, 第二期

### 2.1 功能要求

>断点续传
>
>```C
>// 假设客户端从服务器下载文件的时候, 假设文件215M, 如果下载了以16M之后, 传输由于其它原因断开, 下一次重新下载这个文件的时候, 在当前已经下载16M的基础上, 继续接着下载
>
>// 假设客户端向服务器上传文件的时候, 假设文件215M, 如果上传了16M之后, 传输由于其它原因断开, 下一次重新上传这个文件的时候, 在已经上传16M的基础上, 继续接着上传
>```
>
>mmap传输大文件
>
>```C
>// 当你发现文件大于100M，使用mmap该文件，然后再传输文件
>```

### 2.2 一些想法

#### 断点续传的一些基本想法

>```C
>// 假设客户端向服务器上传文件的时候, 假设文件215M, 如果上传了16M之后, 传输由于其它原因断开, 下一次重新上传这个文件的时候, 在已经上传16M的基础上, 继续接着上传
>
>// 假设客户端从服务器下载文件的时候, 假设文件215M, 如果下载了以16M之后, 传输由于其它原因断开, 下一次重新下载这个文件的时候, 在当前已经下载16M的基础上, 继续接着下载 (选做)
>```
>
>客户端:
>
>```C
>// 在开始下载某个文件之前，客户端检查本地是否已有要下载的文件, 读取这个存在的文件大小
>// 客户端向服务器发送这个文件的大小
>// 服务器根据发送过来的文件名和文件大小, 判断这个文件还有多少内容要继续发送
>// 服务段读取剩余的文件发送给客户端(fseek fread ...)
>// 客户端接收服务端传输内容, 并从指定的偏移量开始写入到本地文件(fseek, fwrite...)
>```
>
>服务器:
>
>```C
>// 同理
>```
>
>怎么判断这两个文件是同一个文件?
>
>```C
>//暂时我们以文件名来判断, 文件名一样我们就认为是同一个文件.
>//(后续我们引入数据库之后, 会用hash值来作为标识文件的标记)
>```
>
>使用断点续传和mmap/sendfile配合使用的时候, 仅让数据发送端使用mmap;  数据接收端不使用mmap,而是使用普通的write, 这样实现起来可能更简单.
>
>```C
>// ps: 如果实在想在接收端使用mmap接收, 可以试图考虑在接收数据的时候,一边填入数据到映射区, 一边记录填入文件的数据量, 然后进行填充结束的时候, 做二次ftruncate文件(避免多余的0存在).
>```

#### mmap传输的一些问题

>```C
>// 当你发现文件大于100M，使用mmap该文件，然后再传输文件
>```
>
>```C
>// 示例代码:
>// 创建一个文件: mmap.txt (假设内部有12288字节的数据)
>// 创建一个文件: mmap_write.txt (假设内部有4160字节的数据)
>// 测试如下代码(感受一下)
>#include <55header.h>
>
>int main(int argc,char*argv[])
>{
>        int file_fd = open("mmap.txt", O_RDWR);
>        struct stat stat_file;
>        fstat(file_fd, &stat_file);
>        char *p = (char *)mmap(NULL, stat_file.st_size-4096, PROT_READ|PROT_WRITE, MAP_SHARED, file_fd, 4096);
>
>        int file_write = open("mmap_write.txt", O_RDWR);
>        ftruncate(file_write, stat_file.st_size);
>        char *p_write = (char *)mmap(NULL, stat_file.st_size-4096, PROT_READ|PROT_WRITE, MAP_SHARED, file_write, 4096);
>
>        memcpy(p_write, p, stat_file.st_size -4096);
>
>        return 0;
>}
>```
>
>其实sendfile也可以控制偏移量: (我们之前上课没讲, 所以有兴趣可以尝试一下)
>
>```C
>#include <sys/sendfile.h>
>ssize_t sendfile(
>        int out_fd, // socket的文件描述符
>        int in_fd, // 要发送的文件
>        off_t *offset, // 偏移量指针
>        size_t count // 要传输的字节数
>);
>// 返回值: 成功时获得sendfile传输的字节数, 出错时返回-1
>```



## 3, 第三期

### 3.1 功能要求

>引入数据库存储文件结构: (虚拟的文件森林)
>
>```C
>// 在我们在第二期时候, 为了解决多个用户的文件分别存储问题(为了实现: 用户之间的文件隔离性, 以及用户自己文件夹的目录之间也存在隔离的问题), 而维护了一个文件目录的森林结构, 这样操作起来最然比较直观和容易理解, 但是文件的组织比较复杂(如果仅站在服务器角度看待这个问题).
>
>// 从存在意义上探究, 我们上面的维护的文件目录森林, 是为了维护文件和文件之间的组织关系. 而当我们学了数据库之后, 这种关系可不可以存在在表中? 用表来模拟这种关系那?
>
>// 答案是肯定的, 那么第三期的以一个任务就是, 我们使用数据库的表, 存储文件夹与文件夹的关系, 存储文件夹与文件间的关系. 以及记录文件对应在文件在服务器的真实位置, 并且给文件一个别名(使用文件的hash值作为别名).
>// 这样我们就可以不用再让服务器维护一个真实的文件目录森林, 就可以把整个服务器的所有文件(不管是那个用户的那个目录下的文件)统一存储到一个固定服务器的真实目录下即可
>```
>
>引入数据库存储用户信息: 
>
>```C
>// 现在我们引入了数据库, 我们就具有一个快捷方便的存储数据的手段(借助数据库), 可以比较方便的在数据库中维护一个用户表, 来存储用户的账号/密码hash值/盐值/用户状态等信息.
>// 这样我们就可以进一步实现登陆注册功能, 注册和登陆的行为, 也可以完全脱离对系统账号的依赖.(就可以随心所欲的注册账号, 和设置密码, 只需要在数据库中存储记录)
>
>// 而在这个过程中, 我们也需要面临给不同用户的密码设置盐值(盐值要随机), 以及根据对应的盐值+原密码生成散列的hash值, 在数据库中只存储密码的hash值.
>// 当用户注册完成重新登陆的时候, 我们根据这个客户端输入的账号查询到对应的盐值, 以及客户端输入的密码, 进行计算hash值, 并和数据库的用户表中存储的hash值做比较, 观察是否正确.
>
>// 有了登陆注册之后, 我们需要对客户端和服务器间的连接, 在新的连接建立之后, 首先就要求登陆账号输入密码并让服务器验证, 才能进行别的所有命令操作. 
>
>// (可选操作)给用户提供注销用户的操作
>
>ps:
>// 在客户端标准输入中,登陆操作用户名建议是(也可以自行决定): login 用户名
>// 在客户端标准输入中,登陆操作中密码建议是(也可以自行决定)(password这个字母应该是客户端的提示字符): password 密码
>```
>
>极速秒传: (客户端先传文件hash值, 比较文件hash值确定服务器是否已经存在这个文件)
>
>```C
>// 我么上面说, 我们要在一个服务器的共同路径下, 存储所有用户的文件, 并且我们会把用户上传的文件的文件名, 改成这个文件的hash值用以标识这个文件.
>
>// 如果存在这么一种情况, 假设zs用户拥有一个名为"熊出没之夺宝奇兵.mp4"的文件, zs把这个文件上传到服务器,这个文件的hash值为:"90be925c5121d21ef13bf8d54f2d5e2565e7c397"
>// 于此同时, 用户ls也有这个名为"熊出没之夺宝奇兵.mp4"的文件, 也准备上传到服务器, 我们可以预料到一种结果, 就是这两个文件本质上是相同的文件, 计算的hash值必然相同, 那我们就没有必要, 也没有道理在服务器维护一个文件存在两份, 我们需要做的, 仅仅是只存储同一份文件, 然后只需要让ls和zs在数据库表中分别都具有对这个文件记录即可.(一个文件被两个人拥有)
>
>// 这样, 当ls上传这个文件的时候, 需要先上传这个文件的hash值给服务器, 当服务器发现已经具有这个hash值的文件, 就认为这两个文件是同一个文件, 不让ls重复上传, 直接提示ls"极速上传成功", 然后再在数据库表中给ls增加对应的指向相同文件的信息记录即可.
>
>//ps: 也有可能是两个完全不同的文件, 经过计算之后hash值以这样(即: hash冲突), 这个情况假设不存在(先不考虑这个情况)
>```
>

### 3.2 一些想法

#### 表模拟文件森林

>仅示例: 假设原本的第二期的文件森林结构:
>
>```sql
>--zs
>----code
>------main.c
>------client.c
>------makefile
>----homework
>------h01.c
>------h02.c
>--ls
>----工作
>------周报.ppt
>------总结.txt
>----生活
>------照片
>--------a.jpg
>--------b.jpg
>------视频
>--------a.mp4
>--------b.map4
>```
>
>**仅示例**: 我们可以设计一个对应的表模拟上述结构:
>
>| id   | 文件名   | 所属用户 | 父目录id | 文件路径(客户端视角) | 文件类型 | 文件的hash值 |
>| ---- | -------- | -------- | -------- | -------------------- | -------- | ------------ |
>| 1    | /        | zs的id   | -1       | /                    | 1        |              |
>| 2    | code     | zs的id   | 1        | /code                | 1        |              |
>| 3    | homework | zs的id   | 1        | /homework            | 1        |              |
>| 4    | mian.c   | zs的id   | 2        | /code/main.c         | 2        | 75b9690....  |
>| 5    | client.c | zs的id   | 2        | /code/client.c       | 2        | 99c5e07....  |
>| 6    | makefile | zs的id   | 2        | /code/makefile       | 2        | 4c5aa3d....  |
>| 7    | h01.c    | zs的id   | 3        | /homework/h01.c      | 2        | 50cdf6d....  |
>| 8    | h02.c    | zs的id   | 3        | /homework/h02.c      | 2        | e9d18c3....  |
>| 9    | /        | ls的id   | -1       | /                    | 1        |              |
>| 10   | 工作     | ls的id   | 9        | /工作                | 1        |              |
>| 11   | 生活     | ls的id   | 9        | /生活                | 1        |              |
>| 12   | 周报.ppt | ls的id   | 10       | /工作/周报.ppt       | 2        | 2f40fb7....  |
>| 13   | 总结.txt | ls的id   | 10       | /工作/总结.txt       | 2        | a416a24....  |
>| 14   | 照片     | ls的id   | 11       | /生活/照片           | 1        |              |
>| 15   | 视频     | ls的id   | 11       | /生活/视频           | 1        |              |
>| 16   | a.jpg    | ls的id   | 14       | /生活/照片/a.jpg     | 2        | 8d556bd....  |
>| 17   | b.jpg    | ls的id   | 14       | /生活/照片/b.jpg     | 2        | 2aaa14c....  |
>| 18   | a.mp4    | ls的id   | 15       | /生活/视频/a.mp4     | 2        | 2f762a12.... |
>| 19   | b.mp4    | ls的id   | 15       | /生活/视频/b.mp4     | 2        | 4cce6bb1.... |

#### 对文件计算hash值

>我们通过上述的表结构来记录用户的存储文件目录结构信息, 就可以不用再让服务器维护一个真实的文件目录森林.
>
>在服务器上做真实文件存储的时候,  就可以把整个服务器的所有文件(不管是那个用户的那个目录下的文件)统一存储到一个固定服务器的真实目录下即可.
>
>在这种情况下, 再给文件使用真实的文件名就不太合适了, 我们可以给文件名使用其对应的hash值进行替换.
>
>```C
>Eg:
>// 假设我们实现服务器的时候, 把所有的用户上传的文件, 都存储到服务器的根目录下的/file目录下
>
>// 此刻, 客户端用户zs有一个a.txt文件要上传到自己云盘的"/文档"目录下, 假设这个a.txt经过计算hash值为"3ac87f3", zs站在客户端的视角, 主观的认为这个文件存在其自己的云盘空间的: "/文档/a.txt"的位置
>// 而作为服务端的实现者, 我们真正需要做的, 其实只是把这个文件的所有信息, 对应的目录结构信息存储到上述表上
>// 然后使用这个文件计算的hash值, 作为一个文件的新的名字, 然后接收客户端上传的"a.txt"重命名为"3ac87f3"文件, 存储到服务器的/file目录下即可 (而这件事情用户是没有感知的, 只有服务器的表中记录了这个关系)
>
>// 当用户zs的客户端处于"文档"(cd 到这个目录)这个目录下时, 想要下载"a.txt"文件的时候, 我们只需要根据"/文档/a.txt"信息查表, 基于zs这个用户, 在服务器的文件记录表中, 找到这个文件的hash值, 根据hash值去服务器的真实目录"/file"下根据这个hash值找到这个文件, 传回给客户端即可
>
>// 这样: 当有个ls也上传了有个别的文件, 也可以以同样的方式放在服务器的真实路径"/file"下, 只要文件的hash值不同, 即可最终分别出不同的文件
>```
>
>**那怎么给文件计算hash值哪?**
>
>```C
>方式一:
>// 调用系统sha1sum 或者 md5sum
>#include <55header.h>
>int main(int argc,char*argv[])
>{
>    char buf[1024];
>    FILE *pipe = popen("sha1sum file.txt", "r");
>    //FILE *pipe = popen("md5sum file.txt", "r");
>
>    fread(buf,1, sizeof(buf), pipe);
>    printf("hash: \n%s", buf);
>
>    pclose(pipe);
>    return 0;
>}
>```
>
>```C
>方式二:
>// 手动实现hash算法计算文件, 网上很多示例, 可以自行搜索 (有时间的话, 说实话,其实很有必要研究一下 )
>// Eg: 仅给一个搜索出来的示例( https://blog.csdn.net/a_ran/article/details/40897159 )
>```
>
>```C
>方式三:
>// 调用第三方轮子实现把文件计算hash值操作
>// Eg: 比如功能强大的openssl库(这个库不仅可以做hash计算, 可以做很多事情, 有兴趣去可以了解了解)
>```

#### Linux系统密码为例的分析: 拓展和铺垫

>我们知道我们的linux中可以有多个用户
>
>```C
>// 创建用户
>sudo useradd -m -s /bin/bash 新用户名
>// 设置密码
>sudo passwd 新用户名
>// 追加权限 (可以不用做)
>sudo usermod -aG sudo zs
>// 切换用户
>su 用户名
>```
>
>```C
>// 查看用户
>cat /etc/passwd
>// 查看用户及其密码相关信息
>sudo cat /etc/shadow
>//用户名:hash密码:最后一次密码更改日期:密码更改最小天数:密码更改最大天数:密码警告天数:密码失效天数:账户失效日期:保留字段
>```
>
>我们从上面的命令中: 可以观察到系统对我们的账号以及密码的存储 (以我的系统为例)
>
>```C
>// snow:$6$gdyR6h8p$la5pLpshjVg.o/YaySKpoQMUsN2QlNoMJHWgXB2l9dLbo/p4OQufyEirat8SGDLT/oqUdz8HjjFNbcfYrvMPL1:19711:0:99999:7:::
>// zs:$6$EcGQ/umB$KkxG5RZFxRR2TYY0uB5y.0eQDu/ONwCGNI7139Zad.pKo4KDP4k0wTOC1qApemHe6n1opZL3rVnvr.EGFZK3a1:19824:0:99999:7:::
>
>其中账号密码部分
>//snow:$6$gdyR6h8p$la5pLpshjVg.o/YaySKpoQMUsN2QlNoMJHWgXB2l9dLbo/p4OQufyEirat8SGDLT/oqUdz8HjjFNbcfYrvMPL1
>//zs:$6$EcGQ/umB$KkxG5RZFxRR2TYY0uB5y.0eQDu/ONwCGNI7139Zad.pKo4KDP4k0wTOC1qApemHe6n1opZL3rVnvr.EGFZK3a1
>    
>    $6$EcGQ/umB$KkxG5RZFxRR2TYY0uB5y.0eQDu/ONwCGNI7139Zad.pKo4KDP4k0wTOC1qApemHe6n1opZL3rVnvr.EGFZK3a1
>
>```
>
>而Linux是怎么实现密码验证的那?
>
>```C
>// 当我们在创建用户之后给用户设置密码的时候, 操作系统会对我们的密码进行散列(MD5、SHA1、SHA-256、SHA-512....), 这个散列过程中会伴随着"加盐"操作(以保证碰撞问题的避免), 等密码经过散列加盐处理之后, 把得到的结果以及盐值存储到/etc/shadow文件中.  
>// (ps: 可以通过修改/etc/login.defs文件的ENCRYPT_METHOD值或其配置文件的其它内容等来指定使用的加密算法和密码策略。)
>
>// 当我们登陆某个账号的时候, 操作系统首先检查输入的用户名是否存在于/etc/passwd文件中存在. 如果这个用户存在, 接下来系统会在/etc/shadow文件中查找与该用户名对应的加密密码记录.
>// 系统使用与存储密码相同的加密算法和从/etc/shadow获取的盐值(保证盐值相同)对用户输入的密码进行重新散列, 得到散列结果之后/etc/shadow文件中存储的密码散列值进行比较, 匹配则代表密码正确.
>```
>
>我们可以通过getspnam来根据Linux系统下的用户名获取密码:
>
>```C
>// getspnam 函数是一个在Linux中用于访问密码文件/etc/shadow的函数。
>
>// (man 3 getspnam)
>#include <shadow.h>
>
>struct spwd *getspnam(
>const char *name//要查询的用户名
>);
>// 返回值: 成功时返回spwd结构指针; 出错或找不到指定的用户返回 NULL。
>```
>
>```C
>struct spwd {
>char *sp_namp;       /* 用户名 */
>char *sp_pwdp;       /* 用户密码 */
>long  sp_lstchg;     /* 最后一次密码更改时间 */
>long  sp_min;        /* 密码最小使用期限 */
>long  sp_max;        /* 密码最大使用期限 */
>long  sp_warn;       /* 密码过期前的警告时间 */
>long  sp_inact;      /* 密码过期后账户被禁用的时间 */
>long  sp_expire;     /* 账户过期时间 */
>unsigned long sp_flag; /* 保留 */
>};
>```
>
>```C
>// 代码示例:
>#include <shadow.h>
>#include <stdio.h>
>#include <stdlib.h>
>
>int main() {
>const char *username = "zs";
>struct spwd *pwd = getspnam(username);
>if (pwd == NULL) {
>  printf("查询出错或者账号不存在 \n");
>  return 0;
>}
>
>printf("UserName: %s\n", pwd->sp_namp);
>printf("Password: %s\n", pwd->sp_pwdp);
>
>return 0;
>}
>```
>
>我们可以通过crypt函数对密码进行散列:
>
>```C
>// (man 3 crypt) (有兴趣也可以自行了解crypt函数)
>
>#include <unistd.h>
>#include <crypt.h>
>char *crypt(
>const char *key,// 明文密码
>const char *salt// 盐值
>);
>//返回值: 返回指向散列后的字符串的指针(包括算法标识符和盐值，后跟实际的散列密码)。如果出现错误，可能返回 NULL。
>
>ps:  Link with -lcrypt  
>(gcc crypt.c -o crypt -Wall -g -lcrypt)
>```
>
>```C
>// 代码示例
>#include <unistd.h>
>#include <crypt.h>
>#include <stdio.h>
>
>int main() {
>const char *password = "zs";
>const char *salt = "$6$EcGQ/umB$"; // 使用SHA-512算法
>
>char *encrypted = crypt(password, salt);
>if (encrypted == NULL) {
>  perror("计算失败 \n");
>  return 0;
>}
>
>printf("password: %s\n", encrypted);
>return 0;
>}
>```

#### 密码和hash值

>盐值的规则:
>
>```C
>// 盐值可以随机自行选择方式生成或者随机生成, 只不过要保证每个用户的盐值不同, 建议盐值遵循一定格式
>eg: ($6$ -> sha 512 )
>// $6$gdyR6h8p$
>// $6$EcGQ/umB$
>// ...
>```

>我们有了盐值, 以及密码明文之后, 可以通过crypt函数对密码进行散列: 得到密码的hash值
>
>```C
>// (man 3 crypt) (有兴趣也可以自行了解crypt函数)
>
>#include <unistd.h>
>#include <crypt.h>
>char *crypt(
>        const char *key,// 明文密码
>        const char *salt// 盐值
>);
>//返回值: 返回指向散列后的字符串的指针(包括算法标识符和盐值，后跟实际的散列密码)。如果出现错误，可能返回 NULL。
>
>ps:  Link with -lcrypt  
>(gcc crypt.c -o crypt -Wall -g -lcrypt)
>```
>
>```C
>// 代码示例
>#include <unistd.h>
>#include <crypt.h>
>#include <stdio.h>
>
>int main() {
>   const char *password = "zs";
>   const char *salt = "$6$EcGQ/umB$"; // 使用SHA-512算法
>
>   char *encrypted = crypt(password, salt);
>   if (encrypted == NULL) {
>       perror("计算失败 \n");
>       return 0;
>   }
>
>   printf("password: %s\n", encrypted);
>   return 0;
>}
>```

#### 极速秒传

>在极速秒传的情况下, 确实也有可能是两个完全不同的文件, 经过计算之后hash值以这样(即: hash冲突).
>
>```C
>// 如果我们针对要试图处理这个问题, 我们就需要考虑手动实现hash算法的必要性了.
>// 当我们发现两个文件的hash值相同, 我们担心这可能是两个不同的文件, 但是由于两个文件hash冲突了, 导致hash值相同.
>// 我们可以对这两个文件做二次hash再进行比较, 如果二次hash的结果也形同, 这两个文件不同的概率无限接近于0, 约等于不存在, 我们就可以近似认为两个文件是相同的文件.
>
>二次hash:
>// 二次hash的方式有很多: 我们可以分别截取这两个文件的相同位置的片段, 只用这个片段数据计算hash值
>// 也可以选择文件的前半部分/或者后半部分, 重新hash, 然后再比较结果.
>// 等等方式.....
>```

#### 断点续传

>下面的断点续传的场景描述:只是一些想法, 大家实现的时候不一定要考虑的这么详细, 当然, 也取决于大家是否有时间和想法去实现这些细节.

>我们对于第三期的改进, 对服务器传输文件到客户端的逻辑没有什么大影响.
>
>```C
>当客户端下载文件的时候, 大致流程依旧是:
>// 客户端判断当前是否有这个文件, 如果有这个文件, 获取这个文件大小.
>// 把这个文件名和文件大小传给服务器, 服务器根据这个用户以及文件名, 找到这个文件的hash值(如果有)
>// 根据hash值找到文件, 然后比较服务器存储的文件和客户端存储的文件的大小.
>// 如果发现满足断点续传的条件(客户端文件大小小于服务端文件大小), 做续传
>```
>
>需要注意是, 如果我们要上传文件到服务器, 断点续传有一些小问题要注意
>
>```C
>有可能存在这么一种情况:
>// 假设, 客户端zs上传了一个文件"熊出没之夺宝奇兵.mp4", 这个文件假设500M, 在传输的过程中, 可能由于某种原因连接断开, 只上传成功了100M (当然, 我们也可以让zs下一次完全重新从开头上传, 这也是大多数文件服务器的实现手法, 也确实可以这么做).
>
>// 如果我们在文件成功上传之前, 就在数据库的文件记录表中, 增加了这条信息(并且标记为上传成功), 就有点不太合适(因为这个文件是以hash值命名的, 并且这个文件实际上只有一部分不是个完整的文件, 这可能导致别的人使用, 或者让zs自己下次打开"云盘"的时候以为上传成功了)
>
>// 如果我们为了避免上面问题, 假设我们在成功之前, 不对这个文件做任何记录, 可不可以? (可以是可以, 但是实现起来不太美丽, 因为如果我们在上传完全成功之前没有记录这个文件的信息在数据库, 我们确实也可以通过直接找到系统存储文件位置, 遍历里面的所有文件, 匹配hash值和文件名的方式, 找到这个未传输完毕的文件,  因为服务器存储的文件名是文件的hash值, 而且客户端也会先传上来这个文件hash值, 就可以直接用于比较服务器的文件名, 确实也可以继续进行所谓的断点续传机制, 只是不太美观这个操作)
>// (不太美观的原因: 是因为"信息记录标记机制的分离", 同时存在数据库方式-直接查找方式两种方式, 及其不良好的设计代码的习惯)
>
>为了解决这个问题: (不一定按我说的做, 如果大家有更好的想法, 也可以根据自己的想法实现)
>// 方式一: 如果我们在文件成功上传之前, 我们确实可以在数据库的文件记录表中, 维护这个文件数据的标识, 但是我们可以在表中设计增加一个文件传输是否完成的标记位, 未传输完成之前, 标记为为未成功状态, 传输成功标记为成功状态.  (这样既解决文件记录的问题, 有避免这个文件被乱用)
>// 方式二: 可以单独维护一个"文件上传中"的表, 所有文件在上传之前都记录在这个表里, 上传成功之后, 再把数据转移到真正的文件记录表中. (也可以比较好的解决问题)
>// 或者其它方式...
>```

#### 数据库使用的额外的四个问题

##### 线程安全问题

>````C
>// 在使用MySQL的时候, 我们需要通过我们的c代码调用之前安装好的MySQL官方写好的/我们下载过来的动态库实现MySQL数据库的连接和访问.
>// 访问的整体流程: 初始化MySQL结构体, 建立连接/获得数据库连接, 发送SQL, 或者结果集合, 遍历结果(如果是查询操作), free结果, 释放连接
>// 在这个过程中: 初始化MySQL结构体, 建立连接/获得数据库连接, 这两个步骤底层是由MySQL提供的包实现的, 它未必是线程安全的, 这可能导致我们多个线程假设在某一时刻同时获得连接的话, 有可能导致线程安全问题, 比如两个线程拿到了同一个连接, 这有可能导致查询的结果,获得结果集合的时候, 结果混淆(a拿到了b的结果, b拿到了a的结果)(因为本质上底层是同一个连接嘛)
>// 所以: 在线程准备初始化MySQL结构体, 建立连接/获得数据库连接的时候, 保持线程间操作是互斥的, 或者说保证我们调用动态库中的函数获得连接在多线程环境下是否是“线程安全”的, 就非常重要.
>````
>
>```C
>// 我们可以通过mysql_thread_safe函数来判断当前的多线程环境, 能否保证线程安全
>
>unsigned int mysql_thread_safe(void)
>// 返回值: 1代表线程安全, 0代表线程不安全
>
>```
>
>```C
>// 线程启动时调用:mysql_thread_init,此函数来初始化一个线程的MySQL相关变量
>// (翻译: 可以用于确保MySQL动态库被调用创建数据库连接的时候可以被线程安全的使用)
>bool mysql_thread_init(void)
>// 返回值: 0代表初始化成功, 非0代表失败
>    
>// ps1: 这个函数应该被尽早的调用, 最好是线程一启动就调用
>// ps2: 这个函数可以不用显式调用, 一方面可能当前线程天然能保证MySQL访问的线程安全, 另一方面类似mysql_init()、mysql_connect()等函数底层会隐式的调用mysql_thread_init函数 (先做mysql_thread_safe的判断)
>```
>
>```C
>// 配合mysql_thread_init使用, 用于释放mysql_thread_init所申请的内存, 可以在线程退出之前主动调用
>void mysql_thread_end(void)
>```
>
>```C
>// 线程安全问题的判断
>#include <header.h>
>#include <mysql/mysql.h>
>
>void *func(void *p){
>    // 判断是否线程安全
>    if (mysql_thread_safe()) {
>        printf("son MySQL is thread-safe.\n");
>    } else {
>        printf("son MySQL is not thread-safe.\n");
>    }
>    return NULL;
>}
>int main(){
>
>    pthread_t thread_id;
>    pthread_create(&thread_id, NULL, func, NULL);
>
>    // 判断是否线程安全
>    if (mysql_thread_safe()) {
>        printf("main MySQL is thread-safe.\n");
>    } else {
>        printf("main MySQL is not thread-safe.\n");
>    }
>
>    pthread_join(thread_id, NULL);
>    return 0;
>}
>```

##### 结果集和释放问题

>SQL查询操作, 必须主动去取结果集
>
>```C
>// 如果我们是通过c_api发送的是一个select的查询数据的操作, 记得获取查询结果, 遍历结果(根据需求选择是否遍历), 并且释放结果. 避免本次查询对下次查询结果造成影响.
>```
>

##### SQL注入问题

>需要注意的SQL注入问题 (要求知道有这么一个问题)
>
>```C
>// 在实际使用数据库的时候, 我们在数据库查询的时候, 参数基本上是来自于客户端, 然后我们基于客户端发送过来的信息参数对SQL进行拼接,然后再把拼接好的SQL发送给数据库, 有没有一种可能, 客户端发送过来的参数中, 带有一些SQL关键字, 导致查询结果不正确.
>
>Eg:
>// 假设服务器等待客户端发送过来账号名, 根据账号名去数据库中查询密码.
>服务器的原始SQL:  select password from user where user_name = 客户端传来的参数
>
>// 但是客户端传来的参数未:  'zs or 1=1' 作为用户名
>服务器接收参数没有处理, 直接拼接SQL得到:
>		select password from user where user_name = zs or 1=1
>       
>// 那么这句sql就会把user表中的所有账号的密码都查出来: 这就是sql注入问题
>```
>

>Eg
>
>```sql
>-- 表结构
>CREATE TABLE `User`  (
>  `id` int primary key,
>  `username` varchar(255),
>  `password` varchar(255),
>  `age` int,
>  `address` varchar(255)
>);
>
>INSERT INTO `User` VALUES (1, 'zs', '123', 18, '湖北');
>INSERT INTO `User` VALUES (2, 'ls', '456', 19, '北京');
>INSERT INTO `User` VALUES (3, 'wu', '789', 20, '上海');
>INSERT INTO `User` VALUES (4, 'zl', 'zl', 21, '南京');
>INSERT INTO `User` VALUES (5, 'sq', 'sq', 22, '深圳');
>```
>
>```C
>// 客户端
>#include <header.h>
>
>int main(int argc,char*argv[])
>{
>    int sofd = socket(AF_INET, SOCK_STREAM, 0);
>
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family = AF_INET;
>    sockaddr.sin_addr.s_addr = inet_addr("192.168.106.130");
>    sockaddr.sin_port = htons(atoi("8080"));
>    connect(sofd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>
>    while(1){
>        printf("账号: ");
>        fflush(stdout);
>        char username[60] = {0};
>        read(STDIN_FILENO, username, sizeof(username));
>        username[strlen(username)-1] = 0;
>
>        printf("密码: ");
>        fflush(stdout);
>        char password[60] = {0};
>        read(STDIN_FILENO, password, sizeof(password));
>        password[strlen(password)-1] = 0;
>
>        send(sofd, username, sizeof(username), 0);
>        send(sofd, password, sizeof(password), 0);
>    
>        char res[4096] = {0};
>        recv(sofd, res, sizeof(res), 0);
>        printf("res: %s \n", res);
>
>    }
>
>    close(sofd);
>    return 0;
>}
>```
>
>```C
>// 服务端
>int main(int argc,char*argv[])
>{
>    // 初始化socket
>    int sofd = socket(AF_INET, SOCK_STREAM, 0);
>    int reuse = 1;
>    setsockopt(sofd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family = AF_INET;
>    sockaddr.sin_addr.s_addr = inet_addr("192.168.106.130");
>    sockaddr.sin_port = htons(atoi("8080"));
>    bind(sofd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>    listen(sofd, 10);
>    int net_fd = accept(sofd, NULL, NULL);
>
>    // 初始化mysql
>    MYSQL *mysql = mysql_init(NULL);
>    mysql_set_character_set(mysql, "utf8mb4");
>    mysql_real_connect(mysql, "localhost", "root", "123456", "cpp61", 0, NULL, 0) ;
>
>    // 读取客户端用户密码, 查询账号信息, 返回给客户端
>    while(1){
>
>        // 接收客户端发送过来的账号密码
>        char username[60] = {0};
>        char password[60] = {0};
>
>        recv(net_fd, username, sizeof(username), 0);
>        int ret = recv(net_fd, password, sizeof(password), 0);
>        if(ret == 0){
>            break;
>        }
>
>        // 根据客户端发送的用户密码, 查询数据库获得账号信息
>        char sql_buf[1024] = {0};
>        sprintf(sql_buf, "select * from User where username='%s' and password = '%s' ",
>                username, password);
>
>        mysql_query(mysql, sql_buf);
>        MYSQL_RES *result = mysql_store_result(mysql);
>
>        char buf[4096] = {0};
>        MYSQL_ROW row;
>        while ((row = mysql_fetch_row(result))) {
>            for(int i=0; i<mysql_num_fields(result); i++){
>                strncat(buf, " \t ", 4 );
>                strncat(buf, row[i], strlen(row[i]));
>            }
>            strncat(buf, " \n ", 4 );
>        }
>        mysql_free_result(result);
>
>        // 把账号信息: 回给客户端
>        send(net_fd, buf, sizeof(buf), 0);
>    }
>
>    mysql_close(mysql);
>    close(sofd);
>    return 0;
>}
>```

>改进:
>
>```C
>// 服务端的改进
>#include <header.h>
>#include <mysql/mysql.h>
>
>int main(int argc,char*argv[])
>{
>    // 初始化socket
>    int sofd = socket(AF_INET, SOCK_STREAM, 0);
>    int reuse = 1;
>    setsockopt(sofd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family = AF_INET;
>    sockaddr.sin_addr.s_addr = inet_addr("192.168.106.130");
>    sockaddr.sin_port = htons(atoi("8080"));
>    bind(sofd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>    listen(sofd, 10);
>    int net_fd = accept(sofd, NULL, NULL);
>
>    // 初始化mysql
>    MYSQL *mysql = mysql_init(NULL);
>    mysql_set_character_set(mysql, "utf8mb4");
>    mysql_real_connect(mysql, "localhost", "root", "123456", "cpp61", 0, NULL, 0) ;
>
>    // 读取客户端用户密码, 查询账号信息, 返回给客户端
>    while(1){
>
>        // 接收客户端发送过来的账号密码
>        char username[60] = {0};
>        char password[60] = {0};
>
>        recv(net_fd, username, sizeof(username), 0);
>        int ret = recv(net_fd, password, sizeof(password), 0);
>        if(ret == 0){
>            break;
>        }
>
>        // 根据客户端发送的用户密码, 查询数据库获得账号信息
>
>        char sql_buf[1024] = {0};
>        sprintf(sql_buf, "select * from User where username=? and password = ? ");
>
>        // 设置预处理的sql
>        MYSQL_STMT *stmt = mysql_stmt_init(mysql);
>        mysql_stmt_prepare(stmt, sql_buf, strlen(sql_buf));
>
>        // 放入参数
>        MYSQL_BIND bind[2];
>        memset(bind, 0, sizeof(bind));
>        bind[0].buffer_type = MYSQL_TYPE_STRING;
>        bind[0].buffer = (char *)username;
>        bind[0].buffer_length = strlen(username);
>        bind[1].buffer_type = MYSQL_TYPE_STRING;
>        bind[1].buffer = (char *)password;
>        bind[1].buffer_length = strlen(password);
>        mysql_stmt_bind_param(stmt, bind);
>
>        // 调用执行
>        if (mysql_stmt_execute(stmt)) {
>            printf("Error: %s\n", mysql_stmt_error(stmt));
>        } else {
>            printf("Query executed successfully.\n");
>        }
>
>        // 绑定结果集
>        MYSQL_BIND bind_result[5];
>        char result_column[5][60];
>        memset(bind_result, 0, sizeof(bind_result));
>        memset(result_column, 0, sizeof(result_column));
>
>        for(int k=0; k<5; k++){
>            bind_result[k].buffer_type = MYSQL_TYPE_STRING;
>            bind_result[k].buffer = result_column[k];
>            bind_result[k].buffer_length = sizeof(result_column[k]);
>        }
>        mysql_stmt_bind_result(stmt, bind_result);
>
>        // 获取查询结果
>        char buf[4096] = {0};
>        int fetch_num = mysql_stmt_fetch(stmt);
>
>        if(fetch_num != 0){
>            printf("没有结果 \n");
>            send(net_fd, buf, strlen(buf), 0);
>            mysql_stmt_close(stmt);
>            break;
>        }
>
>        while (fetch_num == 0) {
>            // 拼接结果
>            for(int l=0; l<5; l++){
>                strncat(buf, " \t ", 4 );
>                strncat(buf, result_column[l], strlen(result_column[l]));
>            }
>            strncat(buf, " \n ", 4 );
>            fetch_num = mysql_stmt_fetch(stmt);
>        }
>
>        // 把多行查询结果发送给客户端
>        send(net_fd, buf, strlen(buf), 0);
>        mysql_stmt_close(stmt);
>    }
>
>    mysql_close(mysql);
>    close(sofd);
>    return 0;
>}
>```

##### 数据库连接池优化问题

>数据库连接池的优化: (不用实现, 但是要求知道有这么一个问题)
>
>```C
>// 在我们上面使用数据库连接的过程中, 我们使用数据库连接的时候, 直接创建数据库连接, 用完之后直接关闭, 这样不太好(类比我们为什么要引入进程池和线程池, 是因为频繁的创建和销毁线程开销太大, 也没有意义)
>
>// 如果我们让某个子线程创建一个数据库连接之后, 一直不关闭怎么样, 这样不就避免了频繁的创建和销毁数据库连接, 避免浪费资源了? 即:每一个线程都持有一个独有的数据库连接, 不关闭, 可行不? 
>// 语法上是可行的, 但是也及其不合适, 为什么? 因为当我们线程a持有一个数据库连接的时候, 大多数时候,都没有使用连接, 因为大多数时候没有什么SQL要执行,在做别的逻辑处理/和数据库无关的, 这个数据库连接在空维护状态,在大多数时间, 比较浪费数据库的连接资源.
>
>改进:
>// 我们可不可借助, 进程池和线程池的池化思想, 搞一个数据库连接池那? 
>// 当然可以, 我们维护一个数据库连接池, 维护了一些数据库连接, 任何线程有sql需要执行, 都把sql交给数据库连接池执行, 获得结果. 
>// 这样, 即避免了数据库连接的频繁创建和销毁浪费资源, 也避免了每个线程都占用一个数据库连接而不使用浪费连接的问题.
>```

## 4, 第四期

### 4.1 功能需求

>长短命令分离: 
>
><img src="./项目/原模式.jpg">
>
>```C
>// 我们之前设计的线程池, 是让一个子线程接待一个客户端连接; 在大多数情况下, 服务端的子线程都属于等待命令的状态, 空耗连接
>// 而且我们的操作系统能创建的线程是又是有限的, 如果按照上面的逻辑, 当并发请求多的时候, 最先到来的连接的客户端占用了一个子线程之后, 最先连接的客户端占用了一个子线程进行通讯的时候, 从频率上讲, 发过来的命令不多, 但是会一直占用这个子线程, 而后到来的其它客户端连接, 处于队列中等待, 等待什么时候有线程空闲, 来从队列中取后来的客户端连接, 进而处理任务, 所以, 后到来的客户端连接, 一直在状态饥饿.
>
>// 所以在上面的逻辑中, 我们需要优化我们的线程池, 为了避免一个线程大多数时间处于等待状态, 我们可以把多个客户端用户把能快速处理的任务, 放在一起处理(cd命令, ls命令, pwd命令, mkdir命令......), 都交给固定的线程处理(保证线程忙起来, 保证线程不是总在等待客户端输入操作命令, 保证线程处于合适的/利用率高效的繁忙状态)
>// 我们也可以把不能快速处理/比较耗时的命令(上传和下载文件), 单独让某个子线程处理(让子线程, 也忙起来)
>// 这样的整体改造, 可以使我们的服务器, 每个线程都处于繁忙的处理任务的状态, 具有更高的处理并发请求的能力, 交互更多的客户端连接, 有效的利用好软硬件资源.
>// -> 即让: 服务器分开处理, 长命令(耗时命令), 和短命令(短频快的命令)
>
>// 除了上面的问题以外, 我们的客户端设计逻辑中, 也存在一些问题
>// 在之前的逻辑中, 如果客户端发起上传/下载文件, 如果这个文件比较大, 耗时比较久, 在我们上面的逻辑中, 我们的客户端无法进行额外的任何操作, 只能等到, 文件上传/下载完成之后, 才能做别的命令操作, 这也是及其不合适的
>// 我们可不可以在, 客户端也实现长短命令分离
>// 如果短命令, 就在主线程和服务器交互处理, 如果长命令(比如类似文件上传和下载这种耗时的命令), 就单独在客户端启动一个子线程处理, 这样, 在文件上传和下载的同时, 主线程依旧可以和服务器做别的操作或者信息交互, 不用必须等待文件上传/下载结束
>```
>
>超时踢出:
>
>```C
>// 我们经过上面的改在之后, 确实显著提高了服务器的并发处理性能
>// 但是有可能存在在么一种情况, 某个用户在进行一系列的操作之后(比如:为了下载一个文件), 停止了操作(比如文件正在下载, 但是需要一定时间下载, 用户在等着), 为了让我们的服务器在有限的能力下, 处理更多的连接进来, 可以把超过固定时间的连接给踢除掉.
>// 比如超过30秒的, 没有做任何事情的操作, 服务端和其断开连接
>
>// ps1: 如果连接被踢掉, 建议不要直接让客户端退出, 因为可能正在下载文件
>// ps2: 如果连接被踢掉, 如果客户端没有退出, 甚至客户端的用户都没有感知, 假设客户端用户再继续做操作(比如: 输入了cd dir的命令), 客户端能不能设计成自动重连服务器哪? (当然可以, 选做)
>```

### 4.2 一些想法

#### 设计逻辑

><img src="./项目/长短命令分离.jpg">
>
>一些问题:
>
><img src="./项目/命令分离的问题.jpg">

#### JWT的使用

>JWT (= token :  是一种标准)

>JWT/JSON Web Token:  JWT是一种**开放标准**, 具有在两个实体之间进行数据传输以及验证信息的重要作用，可以让信息在网络上更安全地传递。
>
>JWT的结构通常包含三个部分：头部（Header）、载荷（Payload）、签名（Signature）。
>
>- 头部：包含令牌的类型和所使用的签名算法。
>- 载荷：包含要传递的声明, 例如用户ID、令牌的发行者和过期时间等。
>- 签名：用于验证消息在传输过程中没有被篡改。
>
>```C
>// 一个jwt的token的结构大概是: 头部.荷载.签名
>Eg:
>eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIxNDc0ODM2NDcsInN1YiI6InByb2plY3QgbmFtZSIsImlzcyI6InNub3ciLCJhdWQiOiJ1c2VyIn0.01lC775YBUPYRvhhBis_KKEh6JMwimEll9YLLFwZkWYGym8zeRkmamNpr5g8q7WlygyR3FCbUn91I0y-RR4IDQ 
>  
>eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIxNDc0ODM2NDcsInN1YiI6InByb2plY3QgbmFtZSIsImlzcyI6InNub3dfbGVlIiwiYXVkIjoidXNlciJ9.VnEv9-lo8jRw59-CyFLj19MIIWTwhwdrdeohOx7UH5Ms5akTkNg7whS0EdbL5s0COh3tlo1jaZp5XBNm12mRMQ 
>```
>
>JWT的荷载字段设置:
>
>- iss (issuer)：签发人
>- sub (subject)：主题
>- aud (audience)：受众
>- iat (Issued At)：签发时间
>- exp (expiration time)：过期时间
>- ...
>
>而l8w8jwt是一个使用C语言编写的轻量级的JWT库，并且在轻量级的同时, 它还支持多种JWT签名算法，包括HS256、RS256等，并且提供了支持通过自定义参数对令牌进行详细配置，如有效期、签发者、主题等。(当然类似的库有很多: libjwt,  cjose, jsonwebtoken,pyjwt, jose4j.... )
>
>**使用步骤**
>
>```C
>步骤一: 导包/导入配置文件
>// 把l8w8jwt包下载下来, 导入到到我们的开发环境中/Linux服务器
>// 解压: 
>  tar zxvf l8w8jwt-2.1.7-linux-x86_64.tar.gz 
>```
>
>```C
>步骤二: 配置
>// 把解压的文件, 移动到系统环境中:
>// 1,移动头文件:
>  sudo cp -r l8w8jwt/include/l8w8jwt/ /usr/include/
>   
>// 1,移动动态库:
>  sudo cp l8w8jwt/bin/release/* /usr/lib
>```
>
>```C
>步骤三: 使用
>// 1, 创建.c文件使用: l8w8jwt
>  
>// 2, 增加编译连接(或者修改makefile):  -ll8w8jwt
>```
>
>```C
>// 加密
>#include <55header.h>
>#include <l8w8jwt/encode.h>
>
>int main(void)
>{
> // 用于存储生成的JWT字符串
> char* jwt; 
>
> // JWT字符串的长度
> size_t jwt_length;  
>
> // 初始化编码参数结构体
> struct l8w8jwt_encoding_params params;
> l8w8jwt_encoding_params_init(&params); 
>
> // 设置JWT使用的算法，这里使用HS512
> params.alg = L8W8JWT_ALG_HS512;  
>
> // 设置JWT的主要荷载部分内容:
> // 主题
> params.sub = "project name";  
> // 签发者
> params.iss = "snow";  
> // 接收方
> params.aud = "user";  
> // token过期/有效时间(0x7fffffff:最大值-> 2038年1月19日)
> params.exp = 0x7fffffff;  
> // token签发时间
> params.iat = 0;  
>
> // 设置加密密钥
> params.secret_key = (unsigned char*)"snow string token key";
> params.secret_key_length = strlen((char *)params.secret_key);
>
> // 输出变量
> params.out = &jwt;
> params.out_length = &jwt_length;
>
> // 加密
> l8w8jwt_encode(&params);
>
> // 输出结果
> printf("l8w8jwt create token: %s \n",  jwt);
>
> // 释放token 字符串的内存
> l8w8jwt_free(jwt);
> return 0;
>}
>```
>
>```C
>// 解密
>#include <55header.h>
>#include <l8w8jwt/encode.h>
>#include <l8w8jwt/decode.h>
>
>int main(void)
>{
>	// 初始化解码参数结构体
>  struct l8w8jwt_decoding_params params;
>  l8w8jwt_decoding_params_init(&params);  
>  
>	// 设置JWT使用的算法，这里使用HS512
>  params.alg = L8W8JWT_ALG_HS512;  
>
>  // token值
>  char *str = "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIxNDc0ODM2NDcsInN1YiI6InByb2plY3QgbmFtZSIsImlzcyI6InNub3ciLCJhdWQiOiJ1c2VyIn0.01lC775YBUPYRvhhBis_KKEh6JMwimEll9YLLFwZkWYGym8zeRkmamNpr5g8q7WlygyR3FCbUn91I0y-RR4IDQ";
>  //char *str = "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIxNDc0ODM2NDcsInN1YiI6InByb2plY3QgbmFtZSIsImlzcyI6InNub3dfbGVlIiwiYXVkIjoidXNlciJ9.VnEv9-lo8jRw59-CyFLj19MIIWTwhwdrdeohOx7UH5Ms5akTkNg7whS0EdbL5s0COh3tlo1jaZp5XBNm12mRMQ";
>    
>    // eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIxNDc0ODM2NDcsInN1YiI6IjEyMCIsImlzcyI6InNub3ciLCJhdWQiOiIxMjMifQ.YVkwJPI73DllFkXk8R3ca7cfeW5g2LywliCCNJBDDI7iJ1go0CveztepilX1I4YUWFPyo2tYFUit5BRujZw5og
>
>  // 填入token字符串和长度
>  params.jwt = (char*)str;
>  params.jwt_length = strlen(str);
>
>  // 设置密钥
>  char *key="snow string token key";
>  params.verification_key = (unsigned char*)key;
>  params.verification_key_length = strlen(key);
>
>  // 定义: 接收结果的指针和变量
>  struct l8w8jwt_claim *claims = NULL;
>  size_t claim_count = 0;
>  enum l8w8jwt_validation_result validation_result;
>  
>  // 解码: 获得token中存储的信息
>  int decode_result = l8w8jwt_decode(&params, &validation_result, &claims, &claim_count);
>
>  // 判断是否是正确的token
>  if (decode_result == L8W8JWT_SUCCESS && validation_result == L8W8JWT_VALID) {
>      printf("Token validation successful!\n");
>
>      // 打印token中解码出来的荷载信息
>      for (size_t i = 0; i < claim_count; i++) {
>          printf("Claim [%zu]: %s = %s\n", i, claims[i].key, claims[i].value);
>      }
>      
>  } else {
>      printf("Token validation failed!\n");
>  }
>
>  l8w8jwt_free_claims(claims, claim_count);
>
>  return 0;
>}
>```
>

#### 循环时间轴

>对于超时退出:
>
>````C
>// 如果希望简单省事, 可以仿照我们之前曾经实现过的超时退出机制:
>// 即,监听每一秒就绪一次
>// 只要就绪就更新当前时间, 然后根据当前时间判断每个会话上一次最后发言的时间
>// 超过30s把对端连接关闭
>````
>
>如果决定上面使用起来, 不想一个检测每个连接的上次说话时间, 也可以使用循环的时间环记录:
>
>```C
>// 这个循环时间环可以设置为循环数组或者链表. (假设使用数组)
>// 这个数组长度为30, 从下标0开始到下标29, 每一个下标位置, 都存储一个连接集合
>// 每个下标位置的连接集合, 都用来存储: 0条-n条客户端连接信息
>// 当有连接过来, accept获得连接信息, 把这个连接的信息, 存到对应的下标位置. 下标位置的计算: 使用当前时间和30取余数得到下标
>// 当一次epoll或者select就绪,假设A,B,C三个连接就绪,使用当前时间和30取余数得到下标, 然后把A,B,C的连接信息从其原下标位置, 移到当前新计算的下标位置的集合中
>// 每次时间余数, 循环向后走一位, 判断这个下标位置中集合的每个连接, 是不是上次(30秒)之前放在这的, 是的话把连接踢出
>
>ps: 大家也可以自行在网上搜索"循环队列 超时"等关键字, 查看更细节的图片化的逻辑描述
>```

>标准的基于四期的要求项目的样子:  (几个问题)
>
>````C
>应该是个什么样子(动态线程/数据库连接池/token/path/net_fd......)
>服务器的主应不应该搞一个结构体存储用户的net_fd,path,账号 ,user_id ; (存储这个东西到底是不是token机制)
>客户端发起的每一个命令操作, 要不要都携带token
>path到底应该存在那(客户端?服务器?)
>````

## 5, 第五期

>多点下载:指客户端通过同时连接不同的服务器，将一份大文件拆分为几段，不同数据片段从不同的服务器进行下载
>
>```C
>在这其中又三个问题:
>// 1. 从某台IP服务器上得到具有数据源的服务器地址，然后再从对应的地址进行下载 
>// 2. 数据源服务器, 应该具有完整的数据, 根据客户端的分片要求传输数据
>// 3. 如果多点下载过程中，客户端断开，那么下次重新下载时，需要再次进行多点下载，这就要求客户端本地需要记录多点下载信息，每个位置下载到什么地方 (或者多点下载没有成功, 下次完全重新下载)
>
>本质上讲, 在极限情况下, 多点下载并不能提升下载速度, 而是提升下载的稳定性
>```



**需要大家知道的是, 关于文件在网络上的传输, 还有两个典型的设计,需要大家关注:**

>有兴趣可以去了解下FTP协议: http://blog.csdn.net/yxyhack/article/details/1826256
>
>有兴趣可以去了解P2P协议:http://www.52im.net/thread-50-1-1.html



