>让socket底层基于TCP, 实现代码让两个客户端连接同一个服务端, 两者之间可以相互通信 
>
>```C
>// 服务端
>int main(){
>
>    char *port = "8080";
>    char *ip = "192.168.106.130";// 当前服务器所在的ip地址
>
>    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
>
>    int reuse = 1;
>    setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
>
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family=AF_INET;// ipv4
>    sockaddr.sin_port= htons(atoi(port));// 端口
>    sockaddr.sin_addr.s_addr = inet_addr(ip); // ip地址
>    bind(socket_fd,  (struct sockaddr *)&sockaddr,   sizeof(sockaddr));
>    listen(socket_fd, 10);
>
>    int client1_fd = accept(socket_fd, NULL, NULL);
>    int client2_fd = accept(socket_fd, NULL, NULL);
>
>    fd_set set;
>    while(1){
>
>        FD_ZERO(&set);
>        FD_SET(client1_fd, &set); 
>        FD_SET(client2_fd, &set); 
>        select(10, &set, NULL, NULL, NULL);
>
>        if(FD_ISSET(client1_fd, &set)){
>            char buf[60] = {0};
>            int ret = recv(client1_fd, buf, sizeof(buf), 0);
>            if(ret == 0){
>                break;
>            }
>            send(client2_fd, buf, sizeof(buf), 0);
>        }
>        if(FD_ISSET(client2_fd, &set)){
>            char buf[60] = {0};
>            int ret = recv(client2_fd, buf, sizeof(buf), 0);
>            if(ret == 0){
>                break;
>            }
>            send(client1_fd, buf, sizeof(buf), 0);
>        }
>    }
>
>    close(client1_fd);
>    close(client2_fd);
>    close(socket_fd);
>    return 0;
>}
>```
>
>```C
>// 客户端
>int main(){
>
>    char *port = "8080";
>    char *ip = "192.168.106.130"; 
>    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family = AF_INET;
>    sockaddr.sin_port = htons(atoi(port));
>    sockaddr.sin_addr.s_addr=inet_addr(ip);
>    int res_connect = connect(socket_fd, (struct sockaddr * )&sockaddr ,sizeof(sockaddr) );
>    ERROR_CHECK(res_connect, -1, "connect123");
>
>    fd_set set;
>    while(1){
>        
>        FD_ZERO(&set);
>        FD_SET(STDIN_FILENO, &set);
>        FD_SET(socket_fd, &set);
>        select(10, &set, NULL, NULL, NULL);
>
>        if(FD_ISSET(STDIN_FILENO, &set)){
>            char buf[60] = {0};
>            read(STDIN_FILENO, buf, sizeof(buf));
>            send(socket_fd, buf, sizeof(buf), 0);
>        }
>        if(FD_ISSET(socket_fd, &set)){
>            char buf[60] = {0};
>            ssize_t ret = recv(socket_fd, buf, sizeof(buf), 0);
>            if(ret == 0){
>                printf("对方断开链接 \n");
>                break;
>            }
>            printf("buf: %s \n", buf);
>        }
>    }
>
>    close(socket_fd);
>    return 0;
>}
>```

>编写带有超时踢出的聊天室程序：
>
>客户端和服务端使用tcp通信；
>
>服务端可以处理新客户端的连接和转发消息；
>
>客户端可以连入服务端并发送消息。每个客户端只要有30s未活跃，则被踢出聊天室。
>
>```C
>// 服务端
>typedef struct conn_s{
> int netfd;
> int isalive;
> time_t tagActiveTime;
>} conn_t;
>
>int main(int argc,char*argv[])
>{
>     // 启动socket函数, 获得对应的socket_fd描述符
>     int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
>
>     // 创建服务端的地址和端口
>     struct sockaddr_in sockaddr;
>     sockaddr.sin_family = AF_INET;
>     sockaddr.sin_addr.s_addr = inet_addr("192.168.106.129");
>     sockaddr.sin_port = htons(atoi("8080"));
>
>     // 绑定端口ip
>     bind(socket_fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>     // 监听端口
>     listen(socket_fd, 10);
>
>     // 构建select监听的集合: fd_set类型
>     fd_set set;
>     // 清空set: 初始化set
>     FD_ZERO(&set);
>     FD_SET(socket_fd, &set);
>
>     // 客户端数组: 用于保存所有链接服务器的客户端
>     conn_t list[1024] ;
>     memset(list, 0 , sizeof(list));
>     // 客户端的存在个数
>     int index;
>
>     while(1){
>       // 构建此次的监听集合
>       fd_set temp_set;
>       // 把set记录复制到本次监听集合
>       memcpy(&temp_set, &set, sizeof(set));
>
>       // select开始监听有没有就绪事件
>        struct timeval timev;
>          timev.tv_sec = 1;
>          timev.tv_usec = 0;
>         select(100, &temp_set, NULL, NULL, &timev);
>
>       // 判断是否有socket数据达到:即socket就绪
>       if(FD_ISSET(socket_fd, &temp_set)){
>           // 获得一个新的客户端链接
>           int netfd = accept(socket_fd, NULL, NULL);
>           // 保存到""客户端""链接数组中
>           list[index].isalive = 0;
>           list[index].netfd = netfd;
>           //list[index].tagActiveTime = time(NULL);
>           time(&list[index].tagActiveTime);
>           // 下一次增加监听这个客户端
>           FD_SET(netfd, &set);
>
>           index++;
>       }
>       // 遍历客户端列表 
>       for(int i=0; i<index; i++){
>           // 当前遍历的客户端
>           conn_t con = list[i];
>           // 判断这个客户端是否存活, 以及是否就绪: 即是否有消息到来
>           if(con.isalive == 0 && FD_ISSET(con.netfd, &temp_set)){
>               // 该客户端存活, 且处于就绪状态
>               // 读取客户端的到达信息
>               char buf[60] = {0};
>               int res_recv = recv(con.netfd, buf, sizeof(buf), 0);
>               // 如果返回值为0, 说明这个客户端已经断开
>               if(res_recv == 0){
>                   // 把客户端数组中该标记置为1: 即非存活状态
>                   list[i].isalive = 1;
>                   // 取消后续对次客户端的select监控
>                   FD_CLR(con.netfd, &set);
>                   // 关闭这个客户端
>                   close(list[i].netfd);
>               }else{
>                   // 把读取到的数据, 分发给别的客户端
>                   // 遍历所有客户端
>                   for(int j=0; j<index; j++){
>                       if(list[j].isalive != 0|| j == i){
>                           // 跳过断开链接的客户端, 跳过发信息过来的客户端
>                           continue;
>                       }
>                       // 发送信息
>                       send(list[j].netfd, buf, sizeof(buf), 0);
>                   }
>                   // 更新这个客户端的活跃时间标记
>                   // list[i].tagActiveTime = time(NULL);
>                   time(&list[i].tagActiveTime);
>               }
>           }
>       }
>       // 判断那个活跃的链接, 已经沉默超过5秒了
>       for(int i=0; i<index; i++){
>           // 获得当前时间
>           time_t now;
>           time(&now);
>           // 判断活跃时间是否超过30秒
>           if(list[i].isalive == 0 && now - list[i].tagActiveTime > 30){
>               // 踢出链接
>               close(list[i].netfd);
>               // 标记不活跃
>               list[i].isalive = 1;
>               // 下次不在监听
>               FD_CLR(list[i].netfd, &set);
>           }
>       }
>     }
>     close(socket_fd);
>     return 0;
>}
>```

>```C
>有客户端和服务器两个工作在不同目录下的程序,  在客户端程序的同级路径下有一个1.txt文件(非大文件, <100字节), 让我们试图通过网络通信的方式, 让客户端把文件传输给服务器保存在服务器的同级目录下. 要求文件最终文件名/大小/内容保持一致
>
>试着补全如下代码: 
>int main(){// 客户端
>
>    char *file_name="1.txt";
>    // socket
>    //...
>    // open
>    // read
>    //....
>    // send
>    //.... 
>    return 0;
>}
>int main(){// 服务端
>    // socket
>    // accept
>    //...
>    // recv
>    //....
>    // open(....O_CREAT....)
>    // write
>    //.... 
>    return 0;
>}
>```
>
>```C
>int main(){
>
>    char *file_name="1.txt";
>
>    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family = AF_INET;
>    sockaddr.sin_port = htons(atoi("8080"));
>    sockaddr.sin_addr.s_addr = inet_addr("192.168.106.130");
>    connect(socket_fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>
>    int name_len = strlen(file_name);
>    send(socket_fd, &name_len, sizeof(int), 0);
>    send(socket_fd, file_name, name_len, 0);
>
>    int file_fd = open(file_name, O_RDWR);
>    char buf[1024] = {0};
>    int file_len = read(file_fd, buf, sizeof(buf));
>    send(socket_fd, &file_len, sizeof(int), 0);
>    send(socket_fd, buf, file_len, 0);
>
>    close(socket_fd);
>    return 0;
>}
>```
>
>```C
>int main(){
>
>    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
>
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family = AF_INET;
>    sockaddr.sin_port = htons(atoi("8080"));
>    sockaddr.sin_addr.s_addr = inet_addr("192.168.106.130");
>    bind(socket_fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>    listen(socket_fd, 10);
>    int net_fd = accept(socket_fd, NULL, NULL);
>
>    int name_len;
>    recv(net_fd, &name_len, sizeof(int), 0);
>    char file_name[100] = {0};
>    recv(net_fd, file_name, name_len, 0);
>
>    int  file_fd = open(file_name, O_RDWR|O_CREAT, 0600);
>    char buf[1024] = {0};
>    int file_len;
>    recv(net_fd, &file_len, sizeof(int), 0);
>    recv(net_fd, buf, file_len, 0);
>    write(file_fd, buf, file_len);
>
>    close(file_fd);
>    close(socket_fd);
>    return 0;
>}
>```
>
>