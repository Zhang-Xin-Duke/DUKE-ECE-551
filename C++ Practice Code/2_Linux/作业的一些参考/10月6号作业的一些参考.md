>什么是大端模式和小端模式，什么是主机字节序和网络字节序？编写代码，验证一下自己的机器是大端模式还是小端模式？
>
>```C
>大端模式/大端法/Big-Endian: 是指`高位字节`存储在内存的`低地址`端,而低位字节存储在内存的高地址端。
>小端模式/小端法/Little-Endian: 和大端法相反,`低位字节`存储在内存的`低地址`端,高位字节存储在内存的高地址端。
>
>Eg: 代码示例: 参考我们上课代码
>int main(int argc,char*argv[])
>{
>// 先定义一个int数据
>int num = 0x75767778;
>// 75 -> 高字节位
>// 78 -> 低字节位
>// 小端法: (低地址 存 低字节位) 78 -> 低地址
>
>// 78  77  76  75
>//低地址        高地址
>// 首地址
>
>// 首地址指向78
>char *c = (char *)&num;
>
>// 78 -> 16进制
>// 0111 1000 -> 二进制
>// 120  -> 10进制
>//  x -> ascii码表
>printf("char : %c \n", *c); // 打印结果x
>
>// htonl: 把主机字节序转成网络字节序 (即:小端 -> 大端)
>int n_num = htonl(num);
>
>// 75  76 77 78
>//低地址        高地址
>//首地址
>
>	//首地址指向75 
>char *c2 = (char *) &n_num;
>
>
>// 75 -> 十六进制
>// 0111 0101 -> 二进制
>// 117 -> 十进制
>// u -> ascii码表
>printf("char : %c \n", *c2);//打印结果u
>return 0;
>}
>```
>
>根据域名，获取一下知名互联网厂商的IP地址信息，如阿里、京东、腾讯、百度。
>
>```C
>
>int main(int argc,char*argv[])
>{
>struct addrinfo *info;
>getaddrinfo("www.baidu.com", NULL, NULL, &info);
>	//getaddrinfo("www.taobao.com", NULL, NULL, &info);
>
>for(struct addrinfo *p = info; p != NULL; p = p->ai_next ){
>   if(p->ai_family == AF_INET){
>       // ipv4
>       struct sockaddr *sockaddr = p-> ai_addr;
>       struct sockaddr_in *sockaddin = (struct sockaddr_in *) sockaddr;
>       struct in_addr addr = sockaddin->sin_addr;
>
>       char *str = inet_ntoa(addr);  
>       printf("ip : %s \n", str);
>   }
>}
>return 0;
>}
>```

>先简单说说socket、bind、listen、accept、connect函数分别有什么基本作用呢？
>
>```C
>// socket: socket函数用来创建一个socket对象, 这个对象中包含一些基本的进行网络通信所需要的各种信息和状态, 其中比较重要的是包含"输入缓冲区"和"输出缓冲区"用来收发网络数据
>// bind: 无论式客户端还是服务器(一般给服务器使用), 都可以通过bind绑定一个用于通信的的端口以及IP地址
>// listen: 当服务器使用listen函数, 可以让服务器根据预设的(bind设置)的端口, 进行通信的监听行为, 监听有没有连接到来
>// connect: 一般由客户端调用, 当connect函数被调用, 当前内核就会促使当前socket对象组织TCP数据段发起三次握手请求, 当connect函数正常成功返回, 则代表通过三次握手, 和服务器间建立了一个TCP通信连接
>```

>使用recv和send函数时发生了什么？
>
>```C
>// send函数的作用是当程序调用send的时候, send函数会把提供给send函数的数据从用户态拷贝到对应的内核态socket对象的输出缓冲区中( 然后后续, 操作系统会把这个socket对象的输出缓冲区的数据拷贝的网卡发送走 )
>// recv函数, 是从指定的内核态的socket对象的输入缓冲区中, 拷贝数据到用户态.
>```

>在net转换的时候, 路由器会做什么事情? 简要说明
>
>```C
>// 将IP数据报的源IP地址从私有局域网地址转换为公网IP地址。
>// 修改TCP或者UDP报文段中的源端口号
>// 更新记录表: 记录刚被被修改的私有IP和端口, 对应其新设置的端口
>// 新端口 <=> 旧私有局域网IP + 被替换前端口
>```
>