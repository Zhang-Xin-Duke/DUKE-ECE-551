>TCP协议如何保证数据的可靠传输?
>
>```C
>// TCP在通信的过程中, 无论是客户端向服务器, 还是服务器向客户端, 在发送TCP信息的时候, 都存在确认机制.
>// 以客户端向服务器传输数据为例: 客户端向服务器传输了一个序号为x并且携带数据量为n的TCP报文段, (刨除掉累积确认的问题)服务端应该向客户端回复一个确认的TCP报文, 在确认号中确认x+n的数据收到了.
>// 这种发送数据和确认的机制, 保证TCP数据即使没有正常到达目标(比如超时), 也可以进行重传.
>// 当然重传行为也发生在当一端期望收到编号为y的TCP信息时, 但是到达的可能是y+100, 或者y+200等编号的TCP信息,这种非预期的数据会导致接收端向发送端重复要求获取编号为y的TCP报文段, 当发送端连续收到三个期望y(等价于对编号y之前的信息的确认)的确认信息, 会重传编号为y的信息.  
>// 而重传机制是保证数据可靠到达的必要也是非常重要的条件之一.
>// 除此之外, TCP还使用窗口机制, 来控制数据发送的流量控制, 防止发送数据过多淹没对方.
>```

>为什么TCP需要三次握手？两次握手为什么不行？
>
>```C
>// TCP三次握手的的本质是一种相互确认双方都知道连接的建立, 第二次握手行为产生标志着"被建立连接端"知道"链接端"试图建立连接, 第三次握手行为到达"被连接端"标志着"被连接端"知道"连接端"已经收到了"确认可以连接"的确认信息.
>
>// 我们可以试图专门举个特殊的反例: 假设两次握手
>//	 假设客户端先向服务器发送一个TCP连接请求, 但是在网络中迷失
>//   而后客户端因为超时, 又发了一个TCP请求连接向服务器, 服务器正常接收, 然后建立连接
>//   然后过了一段时间之后, 迷失在网络种的连接请求到达, 服务器会觉得这个是个新的连接请求, 建立连接, 然后等待对方传输数据
>```

>TCP断开连接时为什么是4次挥手？为什么主动断开的一方要经历TIME_WAIT状态？
>
>```C
>// TCP断开连接时需要四次挥手的主要原因是TCP连接是全双工的, 即数据传输是双向独立的. 这意味着每个方向的终止都需要单独进行.
>
>// 我们可以试图专门举个特殊的反例: 假设四次挥手
>// 		第一次挥手: 比如客户端向服务器发送了断开连接请求.
>//		第二次挥手: 服务器接收到这个请求之后, 但是此时服务器可能还有数据要发给客户端.
>//					这个时候, 服务器会先向客户端发送确认断开连接的确认报文. 让客户先断开, 但是服务端认为自己没有断开
>//					服务器, 则可以继续发送要发给客户端的数据
>//		第三次挥手: 服务器觉得自己数据发送完毕了, 就可以向客户端发起挥手请求
>//      第四次挥手: 由于客户端只收到了第二次挥手, 还没收到服务器的第三次挥手, 则可以继续接收数据
>//				  当收到服务器发送的第三次挥手之后, 给第三次挥手回确认信息, 第四次挥手
>
>// 我们可以试图专门举个特殊的反例: 假设三次挥手
>// 		第一次挥手: 比如客户端向服务器发送了断开连接请求.
>//		第二次挥手: 服务器接收到这个请求之后, 但是此时服务器可能还有数据要发给客户端.
>//                 如果三次挥手的设计, 那么意味着这次挥手, 不仅要求客户端与服务器断开, 也表示服务器要与客户端断开
>//				哪, 从逻辑上服务器有数据也不应该再发了 (不太合理)
>//      第三次挥手: 由于客户端只收到了第二次挥手, 给第二次挥手回确认信息, 第三次挥手
>
>为什么主动断开的一方要经历TIME_WAIT状态
>// 因为在四次挥手的过程中, 客户端担心最后一次断开连接服务器没有收到(丢失), 所以进行2MSL(两个TCP段的最大存活时间)时间的等待
>// 假设当最后一次挥手信息丢失, 服务器就会重新传送断开连接的第三次挥手, 而服务器确认重传的时间为发送完第三次握手的之后的2MSL时间, 此时, 客户端已经发送第四次挥手信息1MSL(大概, 其实还没到1MSL), 所以客户端再等待1MSL(加起来2MSL), 保证服务器如果重新发送来第三次挥手, 客户端依旧能收到.
>```

>通过wireshark抓包分析TCP三次握手过程，
>
>尝试解读TCP协议的每一个字段，截图显示抓包结果。
>
>```C
>// 略(可参考我们上课的文档记录的头部信息对照观察)
>```