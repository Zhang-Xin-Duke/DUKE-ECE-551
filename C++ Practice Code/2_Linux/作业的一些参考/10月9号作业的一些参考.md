>仿照我们之前曾经上课实现的: 客户端和服务端可以分别读取标准输入互发信息的tcp通信.
>
>使用基于udp的socket同样实现一个客户端和服务端可以分别读取标准输入互发信息的代码逻辑. (可以使用select也可以使用epoll做io多路复用, 都可以)
>
>```C
>// UDP的客户端: select实现
>int main(){
>    char *ip = "192.168.106.130";
>    char *port = "8080";
>    
>    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);
>
>    struct sockaddr_in socket_addr;
>    socket_addr.sin_family = AF_INET;
>    socket_addr.sin_port = htons(atoi(port));
>    socket_addr.sin_addr.s_addr = inet_addr(ip);
>
>    fd_set  read_set_base;
>    while(1){
>       FD_ZERO(&read_set_base);
>       FD_SET(STDIN_FILENO, &read_set_base);
>       FD_SET(socket_fd, &read_set_base);
>
>       select(socket_fd+1, &read_set_base, NULL, NULL, NULL);
>       if(FD_ISSET(STDIN_FILENO, &read_set_base)){
>           char buf[60] = {0};
>           read(STDIN_FILENO, buf, sizeof(buf));
>           sendto(socket_fd, buf, sizeof(buf),0,(struct sockaddr *) &socket_addr, sizeof(socket_addr));
>       }
>       if(FD_ISSET(socket_fd, &read_set_base)){
>           char buf[60] = {0};
>           recvfrom(socket_fd,buf,sizeof(buf),0,NULL, NULL);
>           printf("buf %s \n", buf);
>       }
>    }
>    close(socket_fd);
>    return 0;
>}
>```
>
>```C
>// UDP的服务端: select实现
>int main(){
>    char *ip = "192.168.106.130";
>    char *port = "8080";
>    
>    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);
>    struct sockaddr_in socket_addr;
>    socket_addr.sin_family = AF_INET;
>    socket_addr.sin_port = htons(atoi(port));
>    socket_addr.sin_addr.s_addr = inet_addr(ip);
>    bind(socket_fd,(struct sockaddr *)&socket_addr, sizeof(socket_addr));
>
>    struct sockaddr_in client_addr; 
>    memset(&client_addr, 0, sizeof(client_addr));
>
>    fd_set read_set_base;
>    
>    while(1){
>       FD_ZERO(&read_set_base);
>       FD_SET(STDIN_FILENO, &read_set_base);
>       FD_SET(socket_fd, &read_set_base);
>
>       select(socket_fd+1, &read_set_base, NULL, NULL, NULL);
>
>       if(FD_ISSET(STDIN_FILENO, &read_set_base)){
>           char buf[60] = {0};
>           read(STDIN_FILENO, buf, sizeof(buf));
>           if(!client_addr.sin_port){
>               printf("暂时未知客户端,等待客户端连接重新输入 \n");
>           }else{
>               sendto(socket_fd, buf, sizeof(buf),0,(struct sockaddr *)&client_addr,sizeof(client_addr));
>           }
>       }
>       if(FD_ISSET(socket_fd, &read_set_base)){
>           char buf[60] = {0};
>           socklen_t len = sizeof(client_addr);
>           recvfrom(socket_fd, buf, sizeof(buf), 0, (struct sockaddr *)&client_addr, &len);
>           printf("buf %s \n", buf);
>       }
>    }
>    close(socket_fd);
>    return 0;
>}
>```
>
>```C
>// UDP的客户端: epoll实现
>int main(){
>    char *ip = "192.168.106.130";
>    char *port = "8080";
>
>    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);
>
>    struct sockaddr_in socket_addr;
>    socket_addr.sin_family = AF_INET;
>    socket_addr.sin_port = htons(atoi(port));
>    socket_addr.sin_addr.s_addr = inet_addr(ip);
>
>    int epoll_fd = epoll_create(1);
>    struct epoll_event event;
>    event.events = EPOLLIN;
>    event.data.fd=STDIN_FILENO;
>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
>    event.data.fd=socket_fd;
>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &event);
>
>    while(1){
>
>        struct epoll_event list[2];
>        memset(list, 0, sizeof(list));
>
>        int epoll_num = epoll_wait(epoll_fd, list, 2, -1);
>
>        for(int i=0; i<epoll_num; i++){
>            int fd = list[i].data.fd;
>
>            if(fd==STDIN_FILENO){
>                char buf[60] = {0};
>                read(STDIN_FILENO, buf, sizeof(buf));
>                sendto(socket_fd, buf, sizeof(buf),0,(struct sockaddr *) &socket_addr, sizeof(socket_addr));
>            }
>            if(fd==socket_fd){
>                char buf[60] = {0};
>                recvfrom(socket_fd,buf,sizeof(buf),0,NULL, NULL);
>                printf("buf %s \n", buf);
>
>            }
>        }
>    }
>    close(socket_fd);
>    return 0;
>}
>```
>
>```C
>// UDP的服务端: epoll实现
>int main(){
>    char *ip = "192.168.106.130";
>    char *port = "8080";
>
>    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);
>    struct sockaddr_in socket_addr;
>    socket_addr.sin_family = AF_INET;
>    socket_addr.sin_port = htons(atoi(port));
>    socket_addr.sin_addr.s_addr = inet_addr(ip);
>    bind(socket_fd,(struct sockaddr *)&socket_addr, sizeof(socket_addr));
>
>    struct sockaddr_in client_addr; 
>    memset(&client_addr, 0, sizeof(client_addr));
>
>    int epoll_fd = epoll_create(1);
>    struct epoll_event event;
>    event.events = EPOLLIN;
>    event.data.fd=STDIN_FILENO;
>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
>    event.data.fd=socket_fd;
>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &event);
>
>    while(1){
>
>        struct epoll_event list[2];
>        memset(list, 0, sizeof(list));
>
>        int epoll_num = epoll_wait(epoll_fd, list, 2, -1);
>
>        for(int i=0; i<epoll_num; i++){
>            int fd = list[i].data.fd;
>
>            if(fd==STDIN_FILENO){
>                char buf[60] = {0};
>                read(STDIN_FILENO, buf, sizeof(buf));
>                if(!client_addr.sin_port){
>                    printf("暂时未知客户端,等待客户端连接重新输入 \n");
>                }else{
>                    sendto(socket_fd, buf, sizeof(buf),0,(struct sockaddr *)&client_addr,sizeof(client_addr));
>                }
>            }
>            if(fd==socket_fd){
>                char buf[60] = {0};
>                socklen_t len = sizeof(client_addr);
>                recvfrom(socket_fd, buf, sizeof(buf), 0, (struct sockaddr *)&client_addr, &len);
>                printf("buf %s \n", buf);
>
>            }
>        }
>    }
>    close(socket_fd);
>    return 0;
>}
>```

>把群聊的代码, 或者把超时踢出的群聊代码, 由之前写的select改为epoll实现
>
>```C
>// 超时踢出的服务端: (包含群聊实现)
>typedef struct conn{
>    int net_fd; // 某个客户端链接的socket对象的文件描述符
>    int alive; // 连接是否存在: 0正常连接,   非0代表连接断开
>    time_t last_time;// 上一次说话的时间
>}conn_t;
>
>int main(){
>
>    char *port = "8080";
>    char *ip = "192.168.106.130";
>
>    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
>    int reuse = 1;
>    setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family=AF_INET;
>    sockaddr.sin_port= htons(atoi(port));
>    sockaddr.sin_addr.s_addr = inet_addr(ip);
>    bind(socket_fd,  (struct sockaddr *)&sockaddr,   sizeof(sockaddr));
>    listen(socket_fd, 10);
>
>    conn_t list[100];
>    memset(list, 0, sizeof(list));
>    int size=0;
>
>    // epoll
>    int epoll_fd = epoll_create(1);
>    struct epoll_event event;
>    event.events = EPOLLIN;
>    event.data.fd=socket_fd;
>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &event);
>
>    while(1){
>
>        struct epoll_event events[2];
>        memset(events, 0, sizeof(events));
>
>        int epoll_num = epoll_wait(epoll_fd, events, 2, 1000);
>
>        for(int i=0; i<epoll_num; i++){
>            int fd = events[i].data.fd;
>
>            if(fd == socket_fd){
>                int net_fd = accept(socket_fd, NULL, NULL);
>
>                list[size].net_fd = net_fd;
>                list[size].alive = 0;
>                time(&list[size].last_time);
>                size++;
>
>                // 把新获得的客户端链接, 也放入下一次监听
>                event.data.fd=net_fd;
>                epoll_ctl(epoll_fd, EPOLL_CTL_ADD, net_fd, &event);
>            }else{
>                char buf[60] = {0};
>                int recv_ret = recv(fd, buf, sizeof(buf), 0);
>                if(recv_ret == 0){
>                    // 移除监听
>                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
>
>                    for(int a=0; a<size; a++){
>                        if(list[a].alive==0 && list[a].net_fd==fd){
>                            list[a].alive = 1;
>                            close(list[a].net_fd);
>                        }
>                    }
>
>                    continue;
>                }
>                // 转发数据
>                for(int j=0; j<size; j++){
>                    if(list[j].alive==0 && list[j].net_fd != fd){
>                        // 说明是一个正常连接, 并且不是我自己
>                        send(list[j].net_fd, buf, sizeof(buf), 0);
>                    }else if( list[j].alive==0 && list[j].net_fd==fd ){
>                        time(&list[j].last_time);
>                    }
>                }
>            }
>        }
>
>        for(int k=0; k<size; k++){
>            time_t now_time;
>            time(&now_time);
>
>            if(list[k].alive==0 && now_time-list[k].last_time >=30){
>                // 超时踢出
>                epoll_ctl(epoll_fd, EPOLL_CTL_DEL, list[k].net_fd, NULL);
>
>                list[k].alive=1;
>                close(list[k].net_fd);
>            }
>        }
>    }
>
>    close(socket_fd);
>    return 0;
>}
>```